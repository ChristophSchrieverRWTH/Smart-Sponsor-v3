\chapter{Realisation}
This chapter details all the information about the realisation of Smart Sponsor. After looking at the chosen programming languages, framework, and IDE, the implementation follows. Design decisions of some impact are expanded upon. Finally, the project will be analyzed from a performance aspect. The conclusions following this analysis will be detailed in the next chapter. The repository of the final code can be found here:
\url{https://github.com/ChristophSchrieverRWTH/Smart-Sponsor-v3}
\section{Tool Selection}
Smart Sponsor's development was separated into the front- and the back-end development. The back-end uses a blockchain for its' data storage. Due to familiarity with curly-bracket languages and the availability of development tools the blockchain of choice was "Ethereum" using its appended programming language "Solidity." The chosen development environment was "Truffle", as it supports unit tests using the "Mocha" testing framework and "Chai" and easy access to a test blockchain. For most of the development the test blockchain "Ganache" was used. For some parts, the browser-based IDE Remix\cite{remix} was used. The back end of the server was run using Node. The full list of packages can be found in the repository.\\
The front end was developed using "Visual Studio Code" as its IDE. The user interface was created using "Bootstrap" and "React." React allows for creating a single-page application and allows for the grouping of HTML elements into components. These components give more structure to the code. The front-end logic was implemented using "JavaScript." Front-end access to the blockchain runs through the browser extension "MetaMask."\\
The version control of Smart Sponsor was secured using GitHub.
\section{Back-End Implementation}
The back-end segment will deal with the Solidity code and some of the unit tests. The front-end part will deal with the flow of information running through the different React components.
\subsection{Verification of Conditions}
As the verification of conditions is one of the fundamental concepts of Smart Sponsor, its implementation stands as the foundation. In this way, the verification can also be seen as an axiom to any of the transactions of the banking system or Smart Sponsor. The smart contract needs to allow adding and checking certificates, but it also needs to accommodate certificates expiring. The process of creating a certificate is detailed in algorithm 1. Checking a certificate requires recalculating the hash. Update which certificates have expired works as described in algorithm 2. Both functions that write on the blockchain are restricted to be useable by the owner only. This security is secured by OpenZeppelin's "Ownable" smart contract\cite{Zeppelin}.\\
\begin{algorithm}
\caption{Creating a Certificate}\label{alg:create}
\begin{algorithmic}
\Require $message.sender = Verification.owner$
\Require $condition \neq null$
\Require $user \neq null$
\Require $expiryDate \neq null$
\State $concat \gets concatenate(condition, user)$ 
\State $certificate \gets hash(concat)$
\If{$certificateTable[certificate] = false$}
    \State $certificateTable[certificate] \gets true $
\EndIf
\State $expiryTable[certificate] \gets expiryDate$
\end{algorithmic}
\end{algorithm}
\\
After sending a request to get a condition c verified the personnel or program responsible for determining a condition is fulfilled would create a certificate for the address of the user who made this request.\\
The central piece of adding and verifying certificates in the verification process is Solidity's hashing algorithm. In practice, this function would get called by the third-party verification service. The keccak256 function belongs to the same family as all the SHA-3 functions do. Apart from being irreversible it also boasts security against collision attacks and length extension attacks. The input we give is a string that results from the concatenation of the user's address and the string representing the condition e.g. "\emph{Younger than 23 years old.}"\\
To concatenate strings the \emph{abi.encode} and \emph{abi.encodePacked} functions exist as default functions given by Solidity. The main difference is in how strings smaller than 32 bytes are handled. Abi.encode always pads up to 32 bytes. The latter is more space-efficient but as it does not pad empty bits the resulting string might run into collision danger:
\begin{equation*}
    keccak(AAA, BBB) \Longleftrightarrow keccak(AA, ABBB)
\end{equation*}
Still, this more compact version is usable without a problem, as we know the length of one of our input strings. An Ethereum address is always 20 bytes large. This represents 40 hex characters. Therefore it is always clear where the address ends and where the condition string starts.\\
\begin{algorithm}
\caption{Expiry of Certificates}\label{alg:update}
\begin{algorithmic}
\Require $message.sender = Verification.owner$
\State $now = block.timestamp$
\ForEach{$certificate \in certificateTable$}
\If{$expiryTable[certificate] < now$}
\State $certificateTable[certificate] \gets false$
\EndIf
\EndFor
\end{algorithmic}
\end{algorithm}
\\
With the hashing algorithm established, the subject of expiry dates remains. Solidity's internal representation of time relies on the timestamp of the block that is currently being mined. While Ethereum uses the UNIX timestamp to denote this time, it can not be guaranteed that all computers are in agreement with what that currently is. This small discrepancy should only become a problem if enough members of the network create a false consensus on what the current timestamp is. At worst this would cause certificates to expire prematurely, which while a nuisance does not pose a security threat. How long a certificate should be set valid depends on the type of certificate. Especially time-sensitive conditions like those pertaining to age or expiry of documents are to be treated carefully. The hashing over conditions is used to increase the privacy of conditions so setting certificates to exact expiration dates might reveal more information than is necessary. The update function needs to be called once a day. This function can only be called by the owner of the contract leading to higher security.\\
\\
In this version of Smart Sponsor, any possible condition is represented through a string. There are no semantic implications given by this string apart from its existence in the database. It would be possible to replace the string with a more complex datatype detailing eligible values for set keys. In this way checking if a condition is fulfilled could be achieved quickly as the possible values for a key are effectively just a lookup. At the same time, this approach limits the possibilities of what can be proven by a certificate which would reduce the applicability of the financial structure outside of Smart Sponsor.\\ 
\\
Another design decision is the question of how granular conditions should be made.
Smart Sponsor's performance increases if conditions are modeled by strings containing delimiters, but to allow users more reusability, both the back-end- and front-end implementations allow for independent condition strings, while not preventing the user from concatenating conditions into a singular string. \\
It is possible to have $n$ conditions all be contained in a single string of length $L = n + n*delimiter$. As the result of the hashing operation, the result is always a 32bytes-string, the length of the input stream is irrelevant. This approach would lead to faster performance as instead of $n$ certificate checks, now only one is necessary. On the other hand, this approach would reduce versatility. Assuming a user is only missing a single certificate out of $m$ conditions this approach would warrant an entirely new certificate leading to bloat in the database and more strain on the user. What kind of certificate to use should be decided on a case-by-case basis. If a certificate is not due to expire soon and can be reused frequently, combining it into a longer string may be advisable. For example: \emph{store=food; fairTrade=true} with ";" working as a delimiter. If delimited strings are used to denote multiple conditions, said string should be made easily available to the public, possibly being denoted by an abbreviation. On the other hand, certificates that express a more fleeting condition like age or enrollment in a certain university should consequently be written as a singular string, also allowing separate expiry dates for separate conditions.\\
\\
The last major design decision deals with the process of certificates expiring. The check for a certificate's expiry date could be done during the lookup in the database. In this way, there are fewer function calls needed to ensure certificates expire. At the same time, this approach slows down any transaction that needs to verify a certificate. For this reason, the choice of an update function was taken. This approach needs either a script or a person to execute this method once per day leading to a marginal increase in effort once a day but allowing faster checking of certificates.

\subsection{Financial Structure}
The underlying financial infrastructure of Smart Sponsor is what enables a proactive implementation of condition-based donations. For ease of reference, the currency detailed in this chapter will henceforth be called "Sponsor Coin." Following a brief consideration of existing token norms, all algorithms dealing with transactions are detailed. Algorithm 3 shows the minting process of new currency. After this algorithm 4 briefly introduces the permission concept, after which algorithms 5 and 6 detail the two transaction methods. The mint function is restricted to only the owner of the smart contract using once again OpenZeppelin\cite{Zeppelin}.\\
\\
Looking at the two most common norms for tokens on blockchains i.e. ERC-20 and ERC-721, neither fully encompass what Sponsor Coin enables. Sponsor Coin is a tokenized form of fiat currency. Every coin is equal in value to every other one. While this at first glance seems similar to ERC-20, the fact that Sponsor Coins can hold vastly different conditions makes them incompatible with this lighter norm. Therefore this approach is a lot closer to ERC-721, also known as Non-Fungible-Token than it is to ERC-20. Every coin is fundamentally different from every other coin. Even if no conditions are attached, they are still separated by their ID. All of them sharing the same value of fiat currency is more of a semantic interpretation than an implemented rule. Yet there exists a need for having different transaction functions, one for normal transactions and one to attach new conditions. Therefore the resulting contract does not follow either norm but it takes a lot of inspiration from ERC-721.\\
\begin{algorithm}
\caption{Minting new Currency}\label{alg:mint}
\begin{algorithmic}
\Require $message.sender = bankOwner$
\Require $user \neq null$
\Require $amount \neq 0$
\State $counter \gets 0$
\While{$counter < amount$}
\State $newCoin \gets new coin(coinID, user, senderCond, receiverCond)$
\State $coinTable[coinID] \gets newCoin$
\State $coinID \gets coinID + 1$
\State $counter \gets counter + 1$
\EndWhile
\end{algorithmic}
\end{algorithm}
\\
SHOULD THIS BE AFTER ALL ALGORITHMS? 
At the start of a Sponsor Coin's life stands the minting process. In practice, this function would get called visiting a bank or a banking website. After transferring an appropriate amount of fiat currency the minting process gets initiated. But the person who paid for a Sponsor Coin does not necessarily have to become the owner of said coin. This functionality could already be seen as a form of payment or get used for concepts such as grants or pocket money. Therefore the minting process should also allow adding conditions.\\
\begin{equation*}
\begin{array}{c}
    mint() \longrightarrow \emph{$User_A$} \longrightarrow attachTransfer(condition) \longrightarrow \emph{$User_B$} \\
    \big\Downarrow \\
    mint(condition) \longrightarrow \emph{$User_B$}
\end{array}
\end{equation*}
This can make the process of getting an empty coin transferred to another person a lot quicker also reducing the number of transactions needed on the blockchain. Still, this feature does not have to be used and is only an optional shortcut.\\
On top of the 0-address not being accessible by default on Ethereum, it also doubles as the place a token might end its life cycle at. This burning of a token is something that is not necessarily desired with Smart Coins as the idea is to have this currency circulate. Nonetheless keeping this design avenue open allows for easier modification in the future.\\
The minting process also dictates how much fiat currency a singular Sponsor Coin represents, though this is not contained in the blockchain. Again there is no right answer. The less a coin represents, the more effort the user has to put in to buy a product. Also increasing the number of coins needed proportionally increases the number of function calls needed adversely affecting performance. On the other hand, the more a coin represents the unwieldier it ends up. A value along the lines of 5€ to 10€ was envisioned while creating donations, but this value would need to be decided on by convention. There are inherent risks of joining the value of Sponsor Coin with the value of fiat currency, as inflation would increase the amount of computing power needed to fulfill transactions, though the ramifications of this fall outside the scope of this chapter.